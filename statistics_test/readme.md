#### 了解数据
##### **数据摘要**
- 描述
    统计理论中用来对数据进行多种基本统计如是否离散、 缺失值、 缺失率、
异常值、 唯一值、 零值、 是否正态分布、 最大值、 最小值、 平均值、 方差进行分
析。
##### **百分位数**
- 描述
    如果将一组数据从小到大排序， 并计算相应的累计百分位， 则某一百分位
所对应数据的值就称为这一百分位的百分位数。 可表示为： 一组 n 个观测值按数
值大小排列。 如， 处于 p%位置的值称第 p 百分位数。

##### **缺失值分析**
- 描述
    对数据列中的缺失值统计数量和比例


##### **频率分布分析**
- 描述
    统计数据在各个频段内的频数， 从而了解数据的分布特点

>选择数据列： 选择需要分析的列
组数： 指的是频数的组数， 如 20 表示将数据由小到大分为 20 段进行频率分布分
析

##### **异常值分析**
- 描述
    分析数据中的异常值， 根据数据分布特性自动设定上下截断点的值， 不在
此范围内的数据为异常值

> 选择数据列： 选择需要分析的列

##### **贡献度分析**
- 描述
    贡献度分析又称为帕累托分析， 是从帕累托分析法衍生出来的一种分析方
法， 反映单个或多个因素对结果的影响程度。
> 选择项目列： 选择作为结果的列（ 单选）
产生效益列： 需要计算贡献度的列（ 单选）



#### 估计总体参数

##### 1.单正态总体的区间估计
方差已知，估计均值：Z检验：
z.test()：BSDA包，调用格式：

```
z.test(x, y = NULL, alternative = "two.sided", mu = 0, sigma.x = NULL, sigma.y = NULL, conf.level = 0.95)  
```

x,y是数值向量，默认y=NULL,即进行单样本的假设检验；
alternative用于指定估计的置信区间，默认为双尾区间，
less表示求置信上限，greate表示求置信下限；
mu表示均值，默认为0，仅在假设检验中起作用；
sigma.x和sigma.y分别指定两个样本总体的标准差；
conf.level指定区间估计的置信水平
simple.z.test()：UsingR包，只能进行置信区间估计，不能实现Z检验。调用格式：<br>

```
simple.z.test(x, sigma, conf.level=0.95)  
```
x是数据向量，sigma是已知的总体标准差，conf.level是置信度。
方差未知，估计均值：用t检验代替Z检验：
t.test():调用格式：
```
t.test(x, y = NULL, alternative=c("two sided","less","greater"), mu = 0,paired = TRUE, var.equal = FALSE, conf.level = 0.95,...) 
```
x，y为样本数据；alternative表示所求置信区间的类型，默认为双尾检验；mu表示均值，均值未知时不需要赋值；paired表示是否是成对检验；var.equal表示双样本的方差是否相等
均值已知/未知，估计方差：
根据均值已知/未知情况，用卡方分布估计方差置信区间，实际情况中均值多为未知。自行编写函数，可用以下代码实现：

```
var.conf.int=function(x,mu=Inf,alpha){  
     n=length(x)  
     if(mu<Inf){  
        s2=sum((x-mu)^2)/n  
        df=n}  
     else{  
        s2=var(x)  
        df=n-1}  
     c(df*s2/qchisq(1-alpha/2,df),df*s2/qchisq*alpha/2,df))}  
```
##### 2.双正态总体的区间估计
当两总体方差已知，估计均值差μ1-μ2：
z.test():BSDA包，调用格式同上：
```
z.test(x, y = NULL, alternative = "two.sided", mu = 0, sigma.x = NULL, sigma.y = NULL, conf.level = 0.95)  
```
当两总体方差未知但相等，估计均值差μ1-μ2：
t.test():调用格式同上
```
t.test(x, y = NULL, alternative=c("two sided","less","greater"), mu = 0,paired = TRUE, var.equal = FALSE, conf.level = 0.95,...)  
```
当两总体方差未知且不等，估计均值差μ1-μ2：
可用t.test(),设置方差不等，也可以自己编写函数，代码如下：
```
twosample.ci2=function(x,y,alpha){  
                n1=length(x);n2=length(y)  
               xbar=mean(x)-mean(y)  
                S1=var(x);S2=var(y)  
nu=(S1/n1+S2/n2)^2/(S1^2/n1^2/(n1-1)+S2^2/n2^2/(n2-1))  
           c(xbar-z,xbar+z)}  
```
两总体方差比的估计：
var.test():调用格式：
```
var.test(x, y, ratio = 1, alternative = c("two.sided","less","greater"), conf.level = 0.95,...)  
```
x,y为样本数据；ratio为原假设的方差比值；alternative设置检验类型为双尾或是单尾；conf.level为置信水平
##### 3.比率的区间估计
用于估计具有某个特征的个体在总体中的比例
prop.test():调用格式：
```
prop.test(x, n, p = NULL, alternative = c("two.sided","less","greater"),conf.level = 0.95,correct = TRUE) 
```
x为具有特征的样本数；n为样本总数；p设置假设检验的原假设比率值；alternative设置检验方式；conf.level为置信水平；correct设置是否使用Yates连续修正，默认为TRUE。
抽样比很小时，可以使用二项式检验：
binom.test():调用格式为：
```
binom.test(x, n, p = 0.5, alternative = c("two.sided","less","greater"),conf.level= 0.95)  
```
参数代表意义与prop.test()一致。


##### **均值的估计（ 单个总体）**
- 描述
    当总体数据非常庞大时很难对每一个对象进行研究， 均值的估计是根据从
总体中抽取的样本估计总体数据均值的方法。

>数据： 选择需要分析的字段（ 单选）
置信区间： 就结果输出为置信区间还是上下限
置信水平： 设置置信水平， 该结果均值出现的概率

##### **均值差的估计（ 两个总体）**
- 描述
    均值差的估计是分别来自两总体的样本数据估计两总体的均值之差， 已知
来自两总体的样本数据估计两份样本的均值差， 判断两份样本是否有差别

>总体 X： 第一个总体样本字段
总体 Y： 第二个总体样本字段
置信区间： 选择输出结果为置信区间还是上下限
置信水平： 设置置信水平


##### **方差的估计（ 单个总体）**
- 描述
    方差的估计是根据从总体中抽取的样本估计总体分布中方差的方法， 总体
数据庞大、 总体的分布形式已知、 总体的样本数据已知。 输出为方差估计的置信
区间。

>数据： 选择需要进行分析的字段（ 单选）
置信区间： 输出置信区间还是上下限
置信水平： 设置置信水平


##### **方差比的估计（ 两个总体）**
- 描述
    方差比的估计是分别来自两总体的样本数据估计两总体的方差之比， 判断
两份样本稳定程度是否一样

>总体 X： 第一个总体样本字段
总体 Y： 第二个总体样本字段
置信区间： 选择输出结果为置信区间还是上下限
置信水平： 设置置信水平



##### **比率的估计（ 单个总体）**
- 描述
    比率的估计是根据样本数据估计总体中'1'所占的比例,总体数据庞大、 总体
的分布形式已知、 总体的样本数据已知。 输出为比率的估计范围。

> 数据： 选择需要进行分析的字段（ 单选）
置信区间： 输出置信区间还是上下限
置信水平： 设置置信水平


##### **比率差的估计（ 两个总体）**
- 描述
    比率差估计是根据样本 X 和样本 Y 估计总体 X 和总体 Y 的比率之差,判断
两份样本中'1'所占的比例是否一样。
> 总体 X： 第一个总体样本字段
总体 Y： 第二个总体样本字段
置信区间： 选择输出结果为置信
置信水平： 设置置信水平

#### 平均数检验
##### **T 检验（ 单个总体）**
- 描述
    T 检验， 亦称 student t 检验（ Student's t test）， 主要用于样本含量较小（ 例
如 n<30）， 总体标准差σ未知的正态分布资料。

数据： 选择需要检验的字段
平均值： 设定假设的均值
原假设： 选择是等于还是不小于、 不大于假设的均值
置信水平： 设置置信水平
```
t.test(sleep$extra,var.equal=T,mu=0)   #mu 总体样本均值
```



##### **T 检验（ 两个总体）**
- 描述
    用 t 分布理论来推论差异发生的概率， 从而比较两个平均数的差异是否显
著； 双总体 t 检验是检验两个样本平均数与其各自所代表的总体的差异是否显著。

总体 X： 第一个总体样本字段
总体 Y： 第二个总体样本字段
原假设： 假设两个总体的均值关系
置信水平： 设置置信水平
方差相等： 选择条件两个总体的方差是否相等
```
sleep_wide <- data.frame(id=1:10,g1=sleep$extra[1:10],g2=sleep$extra[11:20])
t.test(sleep_wide$g1,sleep_wide$g2,var.equal=T,mu =0) #假设两个总体的均值mu=0关系
```
##### **Wilcoxon 符号秩检验**
- 描述
    把观测值和零假设的中心位置之差的绝对值的秩分别按照不同的符号相加
作为其检验统计量。

分析列： 选择统计分析的列字段（ 单选）
中位数： 用户自定义中位数值


#### 相关性分析与检验
##### **相关性分析**
- 描述
     对从上级操作单元节点得到的数据表所选的不同字段间的相关性进行分析，
得到不同字段的相关系数以判定不同字段的相关性大小。

>字段选择： 用户选择进行数据勘察的字段
算法选择： 用户选择使用的算法（皮尔森，斯皮尔曼）


##### **偏相关分析**
- 描述
    当两个变量同时与第三个变量相关时， 需要消除第三个变量的影响时，
使用偏相关分析。 输入为控制变量和分析变量， 控制变量是保持不变的那个变量，
分析变量是需要计算相关性系数的变量， 输出结果为偏相关系数矩阵， 表示分析
变量两两之间的相关性。

> 控制变量： 保持不变的参考变量字段
分析变量： 需要计算相关性系数的变量字段


##### **对应分析**
- 描述
    对应分析又称为相应分析、 R-Q 分析， 是因子分析基础上发展而来的一种
多元统计分析方法， 它主要通过分析属性（ 定性） 与变量构成的列联表来揭示变
量之间的关系， 也是利用降维的思想以达到简化数据结构的目的

> 
变量 X： 用户选择用于统计分析的第一个列字段（ 单选）
变量 Y： 用户选择用于统计分析的第二个列字段（ 单选）

##### **多重对应分析**
- 描述
    多重对应分析是处理多个变量间的特殊的对应分析方法。

>分析列： 用户选择用于统计分析的列字段（ 多选）


##### **相关性检验**
- 描述
    相关性检验就是通过科学的统计方法对数据之间的相关性进行检验的方法。
输出结果为 p 值， 如果 p 值小于置信水平 0.05， 则拒绝原假设， 即变量之间不相
关

>变量列： 用户选择用于作为变量的列字段（ 单选）
目标列： 用户选择用于分析的列字段（ 单选）


##### **秩相关检验**
- 描述
    将两变量 X、 Y 成对的观察值分别从小到大顺序编秩， 若观察值相同取平
均秩次。 将秩次带入公式计算， 由样本算得的秩相关系数是否有统计学意义， 作
假设检验， 原假设为不相关。

>样本 A： 选择统计分析的列字段作为样本 1
样本 B： 选择统计分析的列字段作为样本 2
原假设： 是否相关
检验方法： 选择进行检验的方法
置信水平： 设置置信水平
连续修正： 是或否， 默认否


##### **卡方独立性检验**
- 描述
    根据次数资料判断两类因子彼此相关或相互独立的假设检验。 与适合性检
验同属于卡方检验。

>分析数据： 用户选择用于统计分析的列字段（ 可多选）


#### 回归分析
##### **多重共线性分析**
- 描述
    检验多重共线性是否存在； 估计多重共线性的范围， 即判断哪些变量之间
存在共线性

>选择数据列： 用户选择用于统计分析的列字段（ 多选）

##### **线性回归分析**
- 描述
    线性回归， 是利用数理统计中回归分析， 来确定两种或两种以上变量间相
互依赖的定量关系的一种统计分析方法。 在回归分析中包括两个或两个以上的自
变量， 且因变量和自变量之间是线性关系， 则称为多元线性回归分析。


##### **逐步回归分析**
- 描述
    逐步回归是对一个或多个自变量和因变量之间关系进行建模的一种回归分
析， 通过删除自变量使模型达到最好。 利用建立好的模型和已知的自变量对因变
量进行预测


##### **广义线性模型**
- 描述
    把自变量的线性预测函数当作因变量的估计值
##### **一元多项式回归**
- 描述
    一元多项式回归用来处理一个因变量与和一个自变量之间的关系， 建立变
量之间的的线性模型并根据模型做分析和预测。

>多项次数： 一元 n 次多项式的次数 n
生成回归诊断图： 勾选生成诊断图， 不勾选则不生成。


##### **二次多项式回归**
- 描述
    一元多项式回归用来处理一个因变量与和一个自变量之间的关系， 建立变
量之间的的线性模型并根据模型做分析和预测。

##### **BoxCox 变换**
- 描述
    可以使线性回归模型满足线性性、 独立性、 方差齐性以及正态性的同时又
不丢失信息。 统计建模中常用的一种用于连续的响应变量不满足正态分布的情况
的数据变换。
##### **抗干扰回归**
- 描述
    抗干扰回归拟合数据集中比较好的点， 从而实现高崩溃点的回归估计。 崩
溃点表示的是一个估计量可以承受离群值的最大数目和样本容量之比。 整体稳健
可以用崩溃点来描述， 崩溃点越高， 抵抗离群值的能力越强， 估计越稳健。 抗干
扰回归的目的是使求出的回归系数不受离群值的影响。



#### 判别分析
##### **线性判别分析**
- 描述
     线性判别分析（ Linear Discriminant Analysis）， 是统计学上一种
经典的分析方法， 可以用于对数据进行分类， 首先要用事先分好类的数据对 LDA
进行训练， 建立判别模型， LDA 的基本思想是投影， 将 n 维数据投影到低维空间，
使得投影后组与组之间尽可能分开， 即在该空间中有最佳的可分离性， 而衡量标
准是新的子空间有最大的类间距离和最小的类内距离。

##### **二次判别分析**
- 描述 
    使用二次曲面来将物件或事件分成两个或以上的分类。

#### 聚类分析
##### **系统聚类**
- 描述 
    系统聚类是将各样品分成若干类的方法， 其基本思想是： 先将各样品各看
成一类， 然后规定类与类之间的距离， 选择距离最小的一对合并成新的一类， 计
算新类与其他类之间的距离， 再将距离最近的两类合并， 这样每次减少一类， 直
到获得合适的分类要求为止。

> 分析列： 用户选择用于统计分析的列字段（ 可多选）
聚类方法： 选择使用的聚类方法
距离： 选择距离计算方法
聚类个数： 选择聚类结果的个数
聚类距离： 根据用户输入的类间最小距离可自动确认聚类个数， 类间最小距离与
聚类个数必须二选一。

##### **Kmeans 聚类**
- 描述 
    k-means 算法是很典型的基于距离的聚类算法， 采用距离作为相似性的评
价指标， 即认为两个对象的距离越近， 其相似度就越大。 该算法认为簇是由距离
靠近的对象组成的， 因此把得到紧凑且独立的簇作为最终目标。
聚类可能做为数据预处理的一部分， 用于辅助分类， 对数据贴上标签。

>分析列： 用户选择用于统计分析的列字段（ 可多选）
聚类算法： 选择使用的聚类算法
聚类个数： 选择聚类结果的个数
迭代次数： 进行迭代计算的次数
随机集合数： 结果的集合数
聚类结果集合： 勾选进行集合， 不勾选则不集合


